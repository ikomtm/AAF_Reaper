// aaf_essence_parser.cpp
// Updated logic for resolving EssenceData ↔ MasterMob link in AAF

#include <assert.h>
#include "AAF.h"
#include "aaf_utils.h"

// Utility: Compare MobIDs
bool IsSameMobID(const aafMobID_t& a, const aafMobID_t& b) {
    return memcmp(&a, &b, sizeof(aafMobID_t)) == 0;
}

// Recursively check components (incl. EssenceGroup)
bool ComponentRefersToEssenceMob(IAAFComponent* pComponent, const aafMobID_t& essenceMobID) {
    IAAFSourceClip* pSrcClip = nullptr;
    if (SUCCEEDED(pComponent->QueryInterface(IID_IAAFSourceClip, (void**)&pSrcClip))) {
        aafSourceRef_t ref;
        if (SUCCEEDED(pSrcClip->GetSourceReference(&ref))) {
            pSrcClip->Release();
            return IsSameMobID(ref.sourceID, essenceMobID);
        }
        pSrcClip->Release();
    }
    IAAFSequence* pSeq = nullptr;
    if (SUCCEEDED(pComponent->QueryInterface(IID_IAAFSequence, (void**)&pSeq))) {
        IEnumAAFComponents* pEnum = nullptr;
        if (SUCCEEDED(pSeq->GetComponents(&pEnum))) {
            IAAFComponent* pSubComp = nullptr;
            while (pEnum->NextOne(&pSubComp) == AAFRESULT_SUCCESS) {
                if (ComponentRefersToEssenceMob(pSubComp, essenceMobID)) {
                    pSubComp->Release();
                    pEnum->Release();
                    pSeq->Release();
                    return true;
                }
                pSubComp->Release();
            }
            pEnum->Release();
        }
        pSeq->Release();
    }
    return false;
}

IAAFMob* FindMasterMobFromEssenceData(IAAFHeader* pHeader, IAAFEssenceData* pEssenceData) {
    aafMobID_t essenceMobID;
    IAAFMob* pMob = nullptr;
    if (FAILED(pEssenceData->QueryInterface(IID_IAAFMob, (void**)&pMob))) return nullptr;
    pMob->GetMobID(&essenceMobID);
    pMob->Release();

    IEnumAAFMobs* pEnum = nullptr;
    aafSearchCrit_t crit;
    crit.searchTag = kAAFByMobKind;
    crit.tags.mobKind = kAAFMasterMob;
    if (FAILED(pHeader->GetMobs(&crit, &pEnum))) return nullptr;

    while (pEnum->NextOne(&pMob) == AAFRESULT_SUCCESS) {
        IEnumAAFMobSlots* pSlotEnum = nullptr;
        if (SUCCEEDED(pMob->GetSlots(&pSlotEnum))) {
            IAAFMobSlot* pSlot = nullptr;
            while (pSlotEnum->NextOne(&pSlot) == AAFRESULT_SUCCESS) {
                IAAFSegment* pSegment = nullptr;
                if (SUCCEEDED(pSlot->GetSegment(&pSegment))) {
                    IAAFComponent* pComponent = nullptr;
                    if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFComponent, (void**)&pComponent))) {
                        if (ComponentRefersToEssenceMob(pComponent, essenceMobID)) {
                            pComponent->Release();
                            pSegment->Release();
                            pSlot->Release();
                            pSlotEnum->Release();
                            pEnum->Release();
                            return pMob;
                        }
                        pComponent->Release();
                    }
                    pSegment->Release();
                }
                pSlot->Release();
            }
            pSlotEnum->Release();
        }
        pMob->Release();
    }
    pEnum->Release();
    return nullptr;
}

IAAFEssenceData* FindEssenceDataFromMasterMob(IAAFHeader* pHeader, IAAFMob* pMasterMob) {
    IEnumAAFMobSlots* pSlotEnum = nullptr;
    if (FAILED(pMasterMob->GetSlots(&pSlotEnum))) return nullptr;

    IAAFMobSlot* pSlot = nullptr;
    while (pSlotEnum->NextOne(&pSlot) == AAFRESULT_SUCCESS) {
        IAAFSegment* pSegment = nullptr;
        if (SUCCEEDED(pSlot->GetSegment(&pSegment))) {
            IAAFSourceClip* pSrcClip = nullptr;
            if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFSourceClip, (void**)&pSrcClip))) {
                aafSourceRef_t ref;
                if (SUCCEEDED(pSrcClip->GetSourceReference(&ref))) {
                    IAAFContentStorage* pStorage = nullptr;
                    if (SUCCEEDED(pHeader->GetContentStorage(&pStorage))) {
                        IEnumAAFEssenceData* pEssEnum = nullptr;
                        if (SUCCEEDED(pStorage->EnumEssenceData(&pEssEnum))) {
                            IAAFEssenceData* pEss = nullptr;
                            while (pEssEnum->NextOne(&pEss) == AAFRESULT_SUCCESS) {
                                IAAFMob* pMob = nullptr;
                                if (SUCCEEDED(pEss->QueryInterface(IID_IAAFMob, (void**)&pMob))) {
                                    aafMobID_t eid;
                                    pMob->GetMobID(&eid);
                                    pMob->Release();
                                    if (IsSameMobID(eid, ref.sourceID)) {
                                        pEssEnum->Release();
                                        pStorage->Release();
                                        pSrcClip->Release();
                                        pSegment->Release();
                                        pSlot->Release();
                                        pSlotEnum->Release();
                                        return pEss;
                                    }
                                }
                                pEss->Release();
                            }
                            pEssEnum->Release();
                        }
                        pStorage->Release();
                    }
                }
                pSrcClip->Release();
            }
            pSegment->Release();
        }
        pSlot->Release();
    }
    pSlotEnum->Release();
    return nullptr;
}

std::string GetFileNameFromEssenceDescriptor(IAAFEssenceDescriptor* pEssenceDescriptor) {
    if (!pEssenceDescriptor) return "";

    // ПРИОРИТЕТ 1: Попробуем получить имя из Locator
    IEnumAAFLocators* pLocEnum = nullptr;
    if (SUCCEEDED(pEssenceDescriptor->GetLocators(&pLocEnum))) {
        IAAFLocator* pLoc = nullptr;
        while (pLocEnum->NextOne(&pLoc) == AAFRESULT_SUCCESS) {
            // Попробуем получить путь напрямую из IAAFLocator
            aafCharacter* pPathBuffer = nullptr;
            aafUInt32 bufferSize = 0;
            
            // Get the required buffer size
            if (SUCCEEDED(pLoc->GetPathBufLen(&bufferSize)) && bufferSize > 0) {
                pPathBuffer = new aafCharacter[bufferSize];
                if (SUCCEEDED(pLoc->GetPath(pPathBuffer, bufferSize))) {
                    // Convert from wide char to string
                    std::string path;
                    for (aafUInt32 i = 0; i < bufferSize && pPathBuffer[i] != 0; i++) {
                        path += (char)pPathBuffer[i];
                    }
                    
                    delete[] pPathBuffer;
                    pLoc->Release();
                    pLocEnum->Release();
                    
                    // Extract filename from path
                    size_t lastSlash = path.find_last_of("/\\");
                    if (lastSlash != std::string::npos) {
                        return path.substr(lastSlash + 1);
                    } else {
                        return path; // No path separators, return as is
                    }
                }
                delete[] pPathBuffer;
            }
            pLoc->Release();
        }
        pLocEnum->Release();
    }
    
    // ПРИОРИТЕТ 2: FileDescriptor::GetName() не существует в AAF SDK
    // Пропускаем этот шаг и переходим к следующему приоритету
    
    // ПРИОРИТЕТ 3: Определяем расширение по типу дескриптора и генерируем имя
    std::string extension = ".dat"; // По умолчанию
    
    // Проверяем тип дескриптора для определения правильного расширения
    IAAFWAVEDescriptor* pWaveDesc = nullptr;
    IAAFAIFCDescriptor* pAifcDesc = nullptr;
    IAAFSoundDescriptor* pSoundDesc = nullptr;
    
    if (SUCCEEDED(pEssenceDescriptor->QueryInterface(IID_IAAFWAVEDescriptor, (void**)&pWaveDesc))) {
        extension = ".wav";
        pWaveDesc->Release();
    } else if (SUCCEEDED(pEssenceDescriptor->QueryInterface(IID_IAAFAIFCDescriptor, (void**)&pAifcDesc))) {
        extension = ".aif";
        pAifcDesc->Release();
    } else if (SUCCEEDED(pEssenceDescriptor->QueryInterface(IID_IAAFSoundDescriptor, (void**)&pSoundDesc))) {
        extension = ".wav"; // Общий аудио формат
        pSoundDesc->Release();
    } else {
        // Для других типов используем общее расширение
        extension = ".dat";
    }
    
    // Генерируем fallback имя
    return "embedded_essence" + extension;
}
