#include "aaf_parser.h"
#include "aaf_utils.h"
#include "media_utils.h"
#include "aaf_essence_parser.h"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <functional>

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∞ –∏–º—ë–Ω embedded —Ñ–∞–π–ª–æ–≤ –≤–æ –≤—Ä–µ–º—è –∞–Ω–∞–ª–∏–∑–∞
std::map<std::string, std::string> g_embeddedFileNames;

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è —Å–≤—è–∑–∏ MasterMob MobID (–∏–∑ CSV) —Å –∏–º–µ–Ω–∞–º–∏ —Ñ–∞–π–ª–æ–≤
std::map<std::string, std::string> g_masterMobToFileName;

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ —Å –ø–æ–∑–∏—Ü–∏–µ–π
void processComponentWithPosition(IAAFComponent* pComp, std::ofstream& out, int compIndex, 
                                 aafPosition_t startPosition, 
                                 const std::map<std::string, std::string>& mobIdToName, 
                                 const aafRational_t& editRate,
                                 int& audioClipCount, int& audioFadeCount, int& audioEffectCount) {
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
    aafLength_t length = 0;
    pComp->GetLength(&length);
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö
    IAAFDataDef* pDataDef = nullptr;
    std::string dataType = "Unknown";
    if (SUCCEEDED(pComp->GetDataDef(&pDataDef))) {
        dataType = getDataDefName(pDataDef);
        pDataDef->Release();
    }
    
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
    double startSec = (double)startPosition * editRate.denominator / editRate.numerator;
    double lengthSec = (double)length * editRate.denominator / editRate.numerator;
    double endSec = startSec + lengthSec;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
    IAAFSourceClip* pClip = nullptr;
    IAAFFiller* pFiller = nullptr;
    IAAFTransition* pTransition = nullptr;
    IAAFSequence* pNestedSeq = nullptr;
    IAAFOperationGroup* pOpGroup = nullptr;
    
    if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSourceClip, (void**)&pClip))) {
        // SourceClip - —Å—Å—ã–ª–∫–∞ –Ω–∞ –º–µ–¥–∏–∞
        aafSourceRef_t ref;
        if (SUCCEEDED(pClip->GetSourceReference(&ref))) {
            double sourceStartSec = (double)ref.startTime * editRate.denominator / editRate.numerator;
            
            std::string refID = formatMobID(ref.sourceID);
            std::string fileName = "(unknown)";
            
            // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ–ª—É—á–µ–Ω–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            if (mobIdToName.count(refID)) {
                fileName = mobIdToName.at(refID);
            }
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ SourceClip
            out << "      #" << compIndex << " AUDIO_FILE [" << dataType << "] "
                << "Timeline: " << std::fixed << std::setprecision(3) 
                << startSec << "s -> " << endSec << "s (" << lengthSec << "s) | "
                << "Source: " << ref.startTime << " (" << sourceStartSec << "s) | "
                << "SlotID: " << ref.sourceSlotID << " | "
                << "File: " << fileName << std::endl;
                
            // –ù–ï —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º audioClipCount –¥–ª—è SourceClip - –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –∫–ª–∏–ø–∞–º–∏!
            // –ö–ª–∏–ø—ã - —ç—Ç–æ —Ç–æ–ª—å–∫–æ OperationGroup
        }
        pClip->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFFiller, (void**)&pFiller))) {
        // Filler - fade-in/fade-out/crossfade
        out << "      #" << compIndex << " AUDIO_FADE [" << dataType << "] "
            << "Timeline: " << std::fixed << std::setprecision(3) 
            << startSec << "s -> " << endSec << "s (" << lengthSec << "s)" << std::endl;
            
        if (dataType == "Sound") audioFadeCount++;
        pFiller->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFTransition, (void**)&pTransition))) {
        // Transition - –ø–µ—Ä–µ—Ö–æ–¥ –º–µ–∂–¥—É –∫–ª–∏–ø–∞–º–∏
        aafPosition_t cutPoint = 0;
        pTransition->GetCutPoint(&cutPoint);
        double cutPointSec = (double)cutPoint * editRate.denominator / editRate.numerator;
        
        out << "      #" << compIndex << " TRANSITION [" << dataType << "] "
            << "Timeline: " << std::fixed << std::setprecision(3) 
            << startSec << "s -> " << endSec << "s (" << lengthSec << "s) | "
            << "CutPoint: " << cutPoint << " (" << cutPointSec << "s)" << std::endl;
            
        if (dataType == "Sound") audioFadeCount++;
        pTransition->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSequence, (void**)&pNestedSeq))) {
        // Nested Sequence - –≤–ª–æ–∂–µ–Ω–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        out << "      #" << compIndex << " NESTED_SEQ [" << dataType << "] "
            << "Timeline: " << std::fixed << std::setprecision(3) 
            << startSec << "s -> " << endSec << "s (" << lengthSec << "s)" << std::endl;
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        IEnumAAFComponents* pNestedEnum = nullptr;
        if (SUCCEEDED(pNestedSeq->GetComponents(&pNestedEnum))) {
            IAAFComponent* pNestedComp = nullptr;
            int nestedIndex = 0;
            aafPosition_t nestedPosition = startPosition;
            
            while (SUCCEEDED(pNestedEnum->NextOne(&pNestedComp))) {
                aafLength_t nestedLength = 0;
                pNestedComp->GetLength(&nestedLength);
                
                out << "        ";  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø
                processComponentWithPosition(pNestedComp, out, nestedIndex++, nestedPosition, 
                                           mobIdToName, editRate, audioClipCount, audioFadeCount, audioEffectCount);
                
                nestedPosition += nestedLength;
                pNestedComp->Release();
            }
            pNestedEnum->Release();
        }
        pNestedSeq->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFOperationGroup, (void**)&pOpGroup))) {
        // OperationGroup - —ç—Ñ—Ñ–µ–∫—Ç –∏–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è
        IAAFOperationDef* pOpDef = nullptr;
        std::string opName = "Unknown";
        if (SUCCEEDED(pOpGroup->GetOperationDefinition(&pOpDef))) {
            IAAFDefObject* pDefObj = nullptr;
            if (SUCCEEDED(pOpDef->QueryInterface(IID_IAAFDefObject, (void**)&pDefObj))) {
                aafWChar opNameBuf[256] = {0};
                if (SUCCEEDED(pDefObj->GetName(opNameBuf, sizeof(opNameBuf)))) {
                    opName = wideToUtf8(opNameBuf);
                }
                pDefObj->Release();
            }
            pOpDef->Release();
        }
        
        aafUInt32 numInputs = 0;
        pOpGroup->CountSourceSegments(&numInputs);
        
        out << "      #" << compIndex << " AUDIO_CLIP [" << dataType << "] "
            << "Timeline: " << std::fixed << std::setprecision(3) 
            << startSec << "s -> " << endSec << "s (" << lengthSec << "s) | "
            << "Operation: " << opName << " | Inputs: " << numInputs << std::endl;
            
        if (dataType == "Sound") audioClipCount++;  // –≠—Ç–æ –∞—É–¥–∏–æ–∫–ª–∏–ø!
        
        // –í–ê–ñ–ù–û: –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã —ç—Ñ—Ñ–µ–∫—Ç–∞
        // –û–Ω–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç –Ω–∞—Å—Ç–æ—è—â–∏–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã (SourceClip)
        for (aafUInt32 inputIndex = 0; inputIndex < numInputs; inputIndex++) {
            IAAFSegment* pInputSegment = nullptr;
            if (SUCCEEDED(pOpGroup->GetInputSegmentAt(inputIndex, &pInputSegment))) {
                out << "        Audio File Input #" << inputIndex << ": ";
                
                IAAFComponent* pInputComp = nullptr;
                if (SUCCEEDED(pInputSegment->QueryInterface(IID_IAAFComponent, (void**)&pInputComp))) {
                    aafLength_t inputLength = 0;
                    pInputComp->GetLength(&inputLength);
                    
                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç (—ç—Ç–æ SourceClip —Å –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–º!)
                    processComponentWithPosition(pInputComp, out, inputIndex, startPosition, 
                                               mobIdToName, editRate, audioClipCount, audioFadeCount, audioEffectCount);
                    pInputComp->Release();
                } else {
                    out << "(non-component segment)" << std::endl;
                }
                
                pInputSegment->Release();
            }
        }
        
        pOpGroup->Release();
        
    } else {
        // –ü–æ–ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ
        std::string className = "Unknown";
        
        IAAFObject* pObject = nullptr;
        if (SUCCEEDED(pComp->QueryInterface(IID_IAAFObject, (void**)&pObject))) {
            IAAFClassDef* pClassDef = nullptr;
            if (SUCCEEDED(pObject->GetDefinition(&pClassDef))) {
                IAAFDefObject* pDefObj = nullptr;
                if (SUCCEEDED(pClassDef->QueryInterface(IID_IAAFDefObject, (void**)&pDefObj))) {
                    aafWChar classNameBuf[256] = {0};
                    if (SUCCEEDED(pDefObj->GetName(classNameBuf, sizeof(classNameBuf)))) {
                        className = wideToUtf8(classNameBuf);
                    }
                    pDefObj->Release();
                }
                pClassDef->Release();
            }
            pObject->Release();
        }
        
        out << "      #" << compIndex << " " << className << " [" << dataType << "] "
            << "Timeline: " << std::fixed << std::setprecision(3) 
            << startSec << "s -> " << endSec << "s (" << lengthSec << "s)" << std::endl;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
void processComponent(IAAFComponent* pComp, std::ofstream& out, int compIndex, 
                     const std::map<std::string, std::string>& mobIdToName, 
                     const aafRational_t& editRate,
                     int& audioClipCount, int& audioFadeCount, int& audioEffectCount) {
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
    aafLength_t length = 0;
    pComp->GetLength(&length);
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö
    IAAFDataDef* pDataDef = nullptr;
    std::string dataType = "Unknown";
    if (SUCCEEDED(pComp->GetDataDef(&pDataDef))) {
        dataType = getDataDefName(pDataDef);
        pDataDef->Release();
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
    IAAFSourceClip* pClip = nullptr;
    IAAFFiller* pFiller = nullptr;
    IAAFTransition* pTransition = nullptr;
    IAAFSequence* pNestedSeq = nullptr;
    IAAFOperationGroup* pOpGroup = nullptr;
    
    if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSourceClip, (void**)&pClip))) {
        // SourceClip - —Å—Å—ã–ª–∫–∞ –Ω–∞ –º–µ–¥–∏–∞
        aafSourceRef_t ref;
        if (SUCCEEDED(pClip->GetSourceReference(&ref))) {
            double lengthSec = (double)length * editRate.denominator / editRate.numerator;
            double startSec = (double)ref.startTime * editRate.denominator / editRate.numerator;
            
            std::string refID = formatMobID(ref.sourceID);
            std::string fileName = "(unknown)";
            if (mobIdToName.count(refID)) {
                fileName = mobIdToName.at(refID);
            }
            
            out << "    > Audio File #" << compIndex 
                << " [" << dataType << "]"
                << ": Start=" << ref.startTime << " (" << std::fixed << std::setprecision(3) << startSec << "s)"
                << ", Length=" << length << " (" << lengthSec << "s)"
                << ", SlotID=" << ref.sourceSlotID
                << ", MobID=" << refID
                << ", File=" << fileName << std::endl;
                
            // –ù–ï —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º audioClipCount –¥–ª—è SourceClip - –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –∫–ª–∏–ø–∞–º–∏!
        }
        pClip->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFFiller, (void**)&pFiller))) {
        // Filler - fade-in/fade-out/crossfade
        double lengthSec = (double)length * editRate.denominator / editRate.numerator;
        out << "    > Audio Fade #" << compIndex 
            << " [" << dataType << "]"
            << ": Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)" << std::endl;
            
        if (dataType == "Sound") audioFadeCount++;
        pFiller->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFTransition, (void**)&pTransition))) {
        // Transition - –ø–µ—Ä–µ—Ö–æ–¥ –º–µ–∂–¥—É –∫–ª–∏–ø–∞–º–∏
        double lengthSec = (double)length * editRate.denominator / editRate.numerator;
        
        aafPosition_t cutPoint = 0;
        pTransition->GetCutPoint(&cutPoint);
        double cutPointSec = (double)cutPoint * editRate.denominator / editRate.numerator;
        
        out << "    > Transition #" << compIndex 
            << " [" << dataType << "]"
            << ": Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)"
            << ", CutPoint=" << cutPoint << " (" << cutPointSec << "s)" << std::endl;
            
        if (dataType == "Sound") audioFadeCount++;
        pTransition->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSequence, (void**)&pNestedSeq))) {
        // Nested Sequence - –≤–ª–æ–∂–µ–Ω–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        double lengthSec = (double)length * editRate.denominator / editRate.numerator;
        out << "    > NestedSequence #" << compIndex 
            << " [" << dataType << "]"
            << ": Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)" << std::endl;
        
        // –ú–æ–∂–Ω–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–ª–æ–∂–µ–Ω–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        IEnumAAFComponents* pNestedEnum = nullptr;
        if (SUCCEEDED(pNestedSeq->GetComponents(&pNestedEnum))) {
            IAAFComponent* pNestedComp = nullptr;
            int nestedIndex = 0;
            while (SUCCEEDED(pNestedEnum->NextOne(&pNestedComp))) {
                out << "      ";  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –¥–ª—è –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                processComponent(pNestedComp, out, nestedIndex++, mobIdToName, editRate, 
                               audioClipCount, audioFadeCount, audioEffectCount);
                pNestedComp->Release();
            }
            pNestedEnum->Release();
        }
        pNestedSeq->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFOperationGroup, (void**)&pOpGroup))) {
        // OperationGroup - —ç—Ñ—Ñ–µ–∫—Ç –∏–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è
        double lengthSec = (double)length * editRate.denominator / editRate.numerator;
        
        IAAFOperationDef* pOpDef = nullptr;
        std::string opName = "Unknown";
        if (SUCCEEDED(pOpGroup->GetOperationDefinition(&pOpDef))) {
            IAAFDefObject* pDefObj = nullptr;
            if (SUCCEEDED(pOpDef->QueryInterface(IID_IAAFDefObject, (void**)&pDefObj))) {
                aafWChar opNameBuf[256] = {0};
                if (SUCCEEDED(pDefObj->GetName(opNameBuf, sizeof(opNameBuf)))) {
                    opName = wideToUtf8(opNameBuf);
                }
                pDefObj->Release();
            }
            pOpDef->Release();
        }
        
        aafUInt32 numInputs = 0;
        if (SUCCEEDED(pOpGroup->CountSourceSegments(&numInputs))) {
            out << "    > Audio Effect #" << compIndex 
                << " [" << dataType << "]"
                << ": Operation=" << opName
                << ", Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)"
                << ", Inputs=" << numInputs << std::endl;
        } else {
            out << "    > Audio Effect #" << compIndex 
                << " [" << dataType << "]"
                << ": Operation=" << opName
                << ", Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)" << std::endl;
        }
        
        if (dataType == "Sound") audioEffectCount++;
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã —ç—Ñ—Ñ–µ–∫—Ç–∞ (—Å–æ–¥–µ—Ä–∂–∞—Ç SourceClip —Å –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞–º–∏)
        for (aafUInt32 inputIndex = 0; inputIndex < numInputs; inputIndex++) {
            IAAFSegment* pInputSegment = nullptr;
            if (SUCCEEDED(pOpGroup->GetInputSegmentAt(inputIndex, &pInputSegment))) {
                out << "      Audio File Input #" << inputIndex << ": ";
                
                IAAFComponent* pInputComp = nullptr;
                if (SUCCEEDED(pInputSegment->QueryInterface(IID_IAAFComponent, (void**)&pInputComp))) {
                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç (SourceClip —Å –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–º)
                    processComponent(pInputComp, out, inputIndex, mobIdToName, editRate, 
                                   audioClipCount, audioFadeCount, audioEffectCount);
                    pInputComp->Release();
                } else {
                    out << "(non-component segment)" << std::endl;
                }
                
                pInputSegment->Release();
            }
        }
        
        pOpGroup->Release();
        
    } else {
        // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
        double lengthSec = (double)length * editRate.denominator / editRate.numerator;
        out << "    > Component #" << compIndex 
            << " [" << dataType << "]"
            << ": Length=" << length << " (" << std::fixed << std::setprecision(3) << lengthSec << "s)"
            << " (unknown type)" << std::endl;
    }
}

void processCompositionSlot(IAAFMobSlot* pSlot, std::ofstream& out, int slotIndex, 
                           const std::map<std::string, std::string>& mobIdToName,
                           int& audioTrackCount, int& audioClipCount, int& audioFadeCount, 
                           int& audioEffectCount, aafPosition_t sessionStartTC) {
    
    aafSlotID_t slotID = 0;
    pSlot->GetSlotID(&slotID);
    
    aafWChar slotName[256] = {0};
    pSlot->GetName(slotName, sizeof(slotName));
    std::string slotNameStr = wideToUtf8(slotName);
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–ª–æ—Ç–∞ –∏ editRate
    aafRational_t editRate = {25, 1}; // default
    std::string slotType = "MobSlot";
    aafPosition_t origin = 0;
    
    IAAFTimelineMobSlot* pTimelineSlot = nullptr;
    if (SUCCEEDED(pSlot->QueryInterface(IID_IAAFTimelineMobSlot, (void**)&pTimelineSlot))) {
        slotType = "TimelineSlot";
        pTimelineSlot->GetEditRate(&editRate);
        pTimelineSlot->GetOrigin(&origin);
        pTimelineSlot->Release();
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å–µ–≥–º–µ–Ω—Ç–∞
    std::string dataType = "Unknown";
    IAAFSegment* pSegment = nullptr;
    if (SUCCEEDED(pSlot->GetSegment(&pSegment))) {
        IAAFComponent* pComp = nullptr;
        if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFComponent, (void**)&pComp))) {
            IAAFDataDef* pDataDef = nullptr;
            if (SUCCEEDED(pComp->GetDataDef(&pDataDef))) {
                dataType = getDataDefName(pDataDef);
                pDataDef->Release();
            }
            pComp->Release();
        }
        pSegment->Release();
    }
    
    // –§–ò–õ–¨–¢–†: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∞—É–¥–∏–æ —Ç—Ä–µ–∫–∏
    if (dataType != "Sound") {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–ª—è –Ω–µ-–∞—É–¥–∏–æ —Ç—Ä–µ–∫–æ–≤
        out << "\n  TRACK #" << slotIndex << " [" << slotType << "] ID=" << slotID;
        if (!slotNameStr.empty()) {
            out << ", Name='" << slotNameStr << "'";
        }
        out << ", DataType=" << dataType << " - SKIPPED (not audio)" << std::endl;
        return;
    }
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞—É–¥–∏–æ —Ç—Ä–µ–∫–æ–≤
    audioTrackCount++;
    
    out << "\n  üéµ AUDIO TRACK #" << slotIndex << " [" << slotType << "] ID=" << slotID;
    if (!slotNameStr.empty()) {
        out << ", Name='" << slotNameStr << "'";
    }
    out << ", DataType=" << dataType;
    out << ", EditRate=" << editRate.numerator << "/" << editRate.denominator;
    out << ", Origin=" << origin;
    if (sessionStartTC != 0) {
        out << ", SessionTC=" << formatTimecode(sessionStartTC, editRate);
    }
    out << std::endl;
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç —Å–ª–æ—Ç–∞
    if (SUCCEEDED(pSlot->GetSegment(&pSegment))) {
        IAAFSequence* pSeq = nullptr;
        IAAFComponent* pComp = nullptr;
        
        if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFSequence, (void**)&pSeq))) {
            // –°–µ–≥–º–µ–Ω—Ç - —ç—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–æ–±—ã—á–Ω—ã–π —Å–ª—É—á–∞–π)
            out << "    üé∂ AUDIO SEQUENCE:" << std::endl;
            
            IEnumAAFComponents* pEnum = nullptr;
            if (SUCCEEDED(pSeq->GetComponents(&pEnum))) {
                IAAFComponent* pSeqComp = nullptr;
                int compIndex = 0;
                aafPosition_t currentPosition = origin + sessionStartTC;
                
                while (SUCCEEDED(pEnum->NextOne(&pSeqComp))) {
                    aafLength_t compLength = 0;
                    pSeqComp->GetLength(&compLength);
                    
                    processComponentWithPosition(pSeqComp, out, compIndex++, currentPosition, 
                                               mobIdToName, editRate, audioClipCount, audioFadeCount, audioEffectCount);
                    
                    currentPosition += compLength;
                    pSeqComp->Release();
                }
                pEnum->Release();
            }
            pSeq->Release();
            
        } else if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFComponent, (void**)&pComp))) {
            // –°–µ–≥–º–µ–Ω—Ç - —ç—Ç–æ –æ—Ç–¥–µ–ª—å–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
            out << "    SINGLE COMPONENT:" << std::endl;
            
            aafPosition_t currentPosition = origin + sessionStartTC;
            processComponentWithPosition(pComp, out, 0, currentPosition, mobIdToName, editRate,
                                       audioClipCount, audioFadeCount, audioEffectCount);
            pComp->Release();
            
        } else {
            // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–µ–≥–º–µ–Ω—Ç–∞
            out << "    UNKNOWN SEGMENT TYPE" << std::endl;
        }
        
        pSegment->Release();
    }
}

void processAudioComponentWithPosition(IAAFComponent* pComp, std::ofstream& out, int compIndex, 
                                      aafPosition_t startPosition, 
                                      const std::map<std::string, std::string>& mobIdToName, 
                                      const aafRational_t& editRate,
                                      int& audioClipCount, int& audioFadeCount, int& audioEffectCount) {
    // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞ processComponentWithPosition, –Ω–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è –∞—É–¥–∏–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    processComponentWithPosition(pComp, out, compIndex, startPosition, mobIdToName, editRate,
                               audioClipCount, audioFadeCount, audioEffectCount);
}

void extractClipsFromSegment(IAAFSegment* pSegment, const std::map<std::string, std::string>& mobIdToName,
                           const aafRational_t& editRate, aafPosition_t sessionStartTC,
                           aafPosition_t currentPosition, AudioTrackData& trackData,
                           IAAFHeader* pHeader, const std::set<std::string>& embeddedMobIDs, std::ofstream& out) {
    
    if (!pSegment) return;
    
    IAAFSequence* pSeq = nullptr;
    IAAFComponent* pComp = nullptr;
    
    if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFSequence, (void**)&pSeq))) {
        // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ - –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º fade/crossfade –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        IEnumAAFComponents* pEnum = nullptr;
        if (SUCCEEDED(pSeq->GetComponents(&pEnum))) {
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤ –≤–µ–∫—Ç–æ—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ fade –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
            std::vector<IAAFComponent*> components;
            std::vector<aafPosition_t> positions;
            
            IAAFComponent* pSeqComp = nullptr;
            aafPosition_t position = currentPosition;
            
            while (SUCCEEDED(pEnum->NextOne(&pSeqComp))) {
                components.push_back(pSeqComp);
                positions.push_back(position);
                
                aafLength_t compLength = 0;
                pSeqComp->GetLength(&compLength);
                position += compLength;
            }
            
            // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã fade/crossfade
            for (size_t i = 0; i < components.size(); i++) {
                IAAFComponent* pCurrentComp = components[i];
                aafPosition_t currentPos = positions[i];
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –∞—É–¥–∏–æ–∫–ª–∏–ø –∏–ª–∏ —ç—Ñ—Ñ–µ–∫—Ç —Å –∞—É–¥–∏–æ–∫–ª–∏–ø–æ–º?
                IAAFSourceClip* pClip = nullptr;
                IAAFOperationGroup* pOpGroup = nullptr;
                
                if (SUCCEEDED(pCurrentComp->QueryInterface(IID_IAAFSourceClip, (void**)&pClip))) {
                    // –≠—Ç–æ SourceClip - —Å–æ–∑–¥–∞–µ–º –∞—É–¥–∏–æ–∫–ª–∏–ø
                    AudioClipData clipData = createClipFromSourceClip(pClip, mobIdToName, editRate, 
                                                                    sessionStartTC, currentPos, pHeader, embeddedMobIDs, out);
                    
                    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º fade –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–æ –∏ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∫–ª–∏–ø–∞
                    analyzeFadePatterns(components, positions, i, editRate, clipData);
                    
                    trackData.clips.push_back(clipData);
                    pClip->Release();
                    
                } else if (SUCCEEDED(pCurrentComp->QueryInterface(IID_IAAFOperationGroup, (void**)&pOpGroup))) {
                    // –≠—Ç–æ OperationGroup - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
                    extractClipsFromComponent(pCurrentComp, mobIdToName, editRate, sessionStartTC,
                                            currentPos, trackData, pHeader, embeddedMobIDs, out);
                    
                    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º fade –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –∫–ª–∏–ø–∞
                    if (!trackData.clips.empty()) {
                        analyzeFadePatterns(components, positions, i, editRate, trackData.clips.back());
                    }
                    
                    pOpGroup->Release();
                    
                } else {
                    // Filler, Transition –∏–ª–∏ –¥—Ä—É–≥–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã - –Ω–µ —Å–æ–∑–¥–∞–µ–º –∫–ª–∏–ø, 
                    // –Ω–æ –æ–Ω–∏ –≤–ª–∏—è—é—Ç –Ω–∞ fade –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–∏–ø–æ–≤
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ analyzeFadePatterns
                }
            }
            
            // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            for (auto comp : components) {
                comp->Release();
            }
            
            pEnum->Release();
        }
        pSeq->Release();
        
    } else if (SUCCEEDED(pSegment->QueryInterface(IID_IAAFComponent, (void**)&pComp))) {
        // –û—Ç–¥–µ–ª—å–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        extractClipsFromComponent(pComp, mobIdToName, editRate, sessionStartTC,
                                currentPosition, trackData, pHeader, embeddedMobIDs, out);
        pComp->Release();
    }
}

void extractClipsFromComponent(IAAFComponent* pComp, const std::map<std::string, std::string>& mobIdToName,
                             const aafRational_t& editRate, aafPosition_t sessionStartTC,
                             aafPosition_t currentPosition, AudioTrackData& trackData,
                             IAAFHeader* pHeader, const std::set<std::string>& embeddedMobIDs, std::ofstream& out) {
    
    if (!pComp) return;
    
    aafLength_t length = 0;
    pComp->GetLength(&length);
    
    double timelineStart = (double)(currentPosition - sessionStartTC) * editRate.denominator / editRate.numerator;
    double clipLength = (double)length * editRate.denominator / editRate.numerator;
    double timelineEnd = timelineStart + clipLength;
    
    IAAFSourceClip* pClip = nullptr;
    IAAFOperationGroup* pOpGroup = nullptr;
    
    if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSourceClip, (void**)&pClip))) {
        // SourceClip - —ç—Ç–æ –∞—É–¥–∏–æ–∫–ª–∏–ø
        aafSourceRef_t ref;
        if (SUCCEEDED(pClip->GetSourceReference(&ref))) {
            AudioClipData clipData;
            
            std::string refID = formatMobID(ref.sourceID);
            clipData.mobID = refID;
            clipData.timelineStart = timelineStart;
            clipData.timelineEnd = timelineEnd;
            clipData.sourceStart = (double)ref.startTime * editRate.denominator / editRate.numerator;
            clipData.length = clipLength;
            
            // –ü–æ–ª—É—á–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞
            // DEBUG: –≤—ã–≤–æ–¥–∏–º MobID –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            out << "    [DEBUG] SourceClip MobID: " << refID << std::endl;
            
            // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è –¥–ª—è Audio Clip
            std::string clipFileName = generateAudioClipFileName(pClip, mobIdToName, pHeader, out);
            
            if (!clipFileName.empty()) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è
                clipData.fileName = clipFileName;
                out << "    [AUDIO_CLIP] Using generated clip file name: " << clipFileName << std::endl;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª embedded
                std::string refMobIdStr = formatMobID(ref.sourceID);
                if (embeddedMobIDs.find(refMobIdStr) != embeddedMobIDs.end()) {
                    // –≠—Ç–æ embedded —Ñ–∞–π–ª - –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –≤ buildEmbeddedFileNameMapping
                    out << "    [EMBEDDED] Found embedded file " << refMobIdStr << " for clip " << clipFileName << std::endl;
                }
            } else {
                // Fallback –∫ —Å—Ç–∞—Ä–æ–π –ª–æ–≥–∏–∫–µ
                // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª embedded
                std::string refMobIdStr = formatMobID(ref.sourceID);
                if (embeddedMobIDs.find(refMobIdStr) != embeddedMobIDs.end()) {
                    // –≠—Ç–æ embedded —Ñ–∞–π–ª - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã
                    auto embeddedIt = g_embeddedFileNames.find(refMobIdStr);
                    if (embeddedIt != g_embeddedFileNames.end()) {
                        clipData.fileName = embeddedIt->second;
                        clipData.mobID = refMobIdStr;
                        out << "    [EMBEDDED] Found embedded audio: " << embeddedIt->second << " with MOB ID: " << refMobIdStr << std::endl;
                    } else {
                        // Fallback –∏–º—è –¥–ª—è embedded —Ñ–∞–π–ª–∞
                        clipData.fileName = "embedded_" + refMobIdStr + ".aif";
                        clipData.mobID = refMobIdStr;
                        out << "    [EMBEDDED] Using fallback name for embedded file: " << clipData.fileName << std::endl;
                    }
                } else if (mobIdToName.count(refID)) {
                    // –§–∞–π–ª external - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è –∏–∑ mobIdToName
                    clipData.fileName = mobIdToName.at(refID);
                } else {
                    // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–∞–π–ª
                    clipData.fileName = "unknown_" + refID;
                }
            }
            
            trackData.clips.push_back(clipData);
        }
        pClip->Release();
        
    } else if (SUCCEEDED(pComp->QueryInterface(IID_IAAFOperationGroup, (void**)&pOpGroup))) {
        // OperationGroup - —ç—Ñ—Ñ–µ–∫—Ç, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –∞—É–¥–∏–æ–∫–ª–∏–ø—ã
        aafUInt32 numInputs = 0;
        if (SUCCEEDED(pOpGroup->CountSourceSegments(&numInputs))) {
            
            // –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å gain –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —ç—Ñ—Ñ–µ–∫—Ç–∞
            double gainValue = 0.0;
            IAAFOperationDef* pOpDef = nullptr;
            if (SUCCEEDED(pOpGroup->GetOperationDefinition(&pOpDef))) {
                IAAFDefObject* pDefObj = nullptr;
                if (SUCCEEDED(pOpDef->QueryInterface(IID_IAAFDefObject, (void**)&pDefObj))) {
                    aafWChar opNameBuf[256] = {0};
                    if (SUCCEEDED(pDefObj->GetName(opNameBuf, sizeof(opNameBuf)))) {
                        std::string opName = wideToUtf8(opNameBuf);
                        // –ï—Å–ª–∏ —ç—Ç–æ Mono Audio Gain, –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∑–Ω–∞—á–µ–Ω–∏–µ gain
                        if (opName.find("Gain") != std::string::npos || opName.find("gain") != std::string::npos) {
                            // TODO: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–æ—á–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è gain –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                            // –ü–æ–∫–∞ —á—Ç–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                            gainValue = 1.0; // 0 dB
                        }
                    }
                    pDefObj->Release();
                }
                pOpDef->Release();
            }
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã —ç—Ñ—Ñ–µ–∫—Ç–∞
            for (aafUInt32 inputIndex = 0; inputIndex < numInputs; inputIndex++) {
                IAAFSegment* pInputSegment = nullptr;
                if (SUCCEEDED(pOpGroup->GetInputSegmentAt(inputIndex, &pInputSegment))) {
                    IAAFComponent* pInputComp = nullptr;
                    if (SUCCEEDED(pInputSegment->QueryInterface(IID_IAAFComponent, (void**)&pInputComp))) {
                        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
                        extractClipsFromComponent(pInputComp, mobIdToName, editRate, sessionStartTC,
                                                currentPosition, trackData, pHeader, embeddedMobIDs, out);
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º gain –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–º—É –∫–ª–∏–ø—É
                        if (!trackData.clips.empty() && gainValue > 0.0) {
                            trackData.clips.back().gain = gainValue;
                        }
                        
                        pInputComp->Release();
                    }
                    pInputSegment->Release();
                }
            }
        }
        pOpGroup->Release();
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    IAAFSequence* pNestedSeq = nullptr;
    if (SUCCEEDED(pComp->QueryInterface(IID_IAAFSequence, (void**)&pNestedSeq))) {
        IAAFSegment* pNestedSegment = nullptr;
        if (SUCCEEDED(pNestedSeq->QueryInterface(IID_IAAFSegment, (void**)&pNestedSegment))) {
            extractClipsFromSegment(pNestedSegment, mobIdToName, editRate, sessionStartTC,
                                  currentPosition, trackData, pHeader, embeddedMobIDs, out);
            pNestedSegment->Release();
        }
        pNestedSeq->Release();
    }
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∞—É–¥–∏–æ–∫–ª–∏–ø–∞ –∏–∑ SourceClip
AudioClipData createClipFromSourceClip(IAAFSourceClip* pClip, const std::map<std::string, std::string>& mobIdToName,
                                      const aafRational_t& editRate, aafPosition_t sessionStartTC,
                                      aafPosition_t currentPosition, IAAFHeader* pHeader, 
                                      const std::set<std::string>& embeddedMobIDs, std::ofstream& out) {
    
    AudioClipData clipData;
    
    aafSourceRef_t ref;
    if (SUCCEEDED(pClip->GetSourceReference(&ref))) {
        // –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏–Ω—É —á–µ—Ä–µ–∑ IAAFComponent –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        IAAFComponent* pComponent = nullptr;
        aafLength_t length = 0;
        if (SUCCEEDED(pClip->QueryInterface(IID_IAAFComponent, (void**)&pComponent))) {
            pComponent->GetLength(&length);
            pComponent->Release();
        }
        
        std::string refID = formatMobID(ref.sourceID);
        clipData.mobID = refID;
        clipData.timelineStart = (double)(currentPosition - sessionStartTC) * editRate.denominator / editRate.numerator;
        clipData.length = (double)length * editRate.denominator / editRate.numerator;
        clipData.timelineEnd = clipData.timelineStart + clipData.length;
        clipData.sourceStart = (double)ref.startTime * editRate.denominator / editRate.numerator;
        
        // –ü–æ–ª—É—á–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞
        // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è –¥–ª—è Audio Clip
        std::string clipFileName = generateAudioClipFileName(pClip, mobIdToName, pHeader, out);
        
        if (!clipFileName.empty()) {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è
            clipData.fileName = clipFileName;
            out << "    [AUDIO_CLIP] Using generated clip file name: " << clipFileName << std::endl;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª embedded
            std::string refMobIdStr = formatMobID(ref.sourceID);
            if (embeddedMobIDs.find(refMobIdStr) != embeddedMobIDs.end()) {
                // –≠—Ç–æ embedded —Ñ–∞–π–ª - –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –≤ buildEmbeddedFileNameMapping
                out << "    [EMBEDDED] Found embedded file " << refMobIdStr << " for clip " << clipFileName << std::endl;
            }
        } else {
            // Fallback –∫ —Å—Ç–∞—Ä–æ–π –ª–æ–≥–∏–∫–µ
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª embedded
            std::string refMobIdStr = formatMobID(ref.sourceID);
            if (embeddedMobIDs.find(refMobIdStr) != embeddedMobIDs.end()) {
                // –≠—Ç–æ embedded —Ñ–∞–π–ª - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã
                auto embeddedIt = g_embeddedFileNames.find(refMobIdStr);
                if (embeddedIt != g_embeddedFileNames.end()) {
                    clipData.fileName = embeddedIt->second;
                    clipData.mobID = refMobIdStr;
                    out << "    [EMBEDDED] Found embedded audio: " << embeddedIt->second << " with MOB ID: " << refMobIdStr << std::endl;
                } else {
                    // Fallback –∏–º—è –¥–ª—è embedded —Ñ–∞–π–ª–∞
                    clipData.fileName = "embedded_" + refMobIdStr + ".aif";
                    clipData.mobID = refMobIdStr;
                    out << "    [EMBEDDED] Using fallback name for embedded file: " << clipData.fileName << std::endl;
                }
            } else if (mobIdToName.count(refID)) {
                // –§–∞–π–ª external - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è –∏–∑ mobIdToName
                clipData.fileName = mobIdToName.at(refID);
            } else {
                // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–∞–π–ª
                clipData.fileName = "unknown_" + refID;
            }
        }
    }
    
    return clipData;
}

// –ê–Ω–∞–ª–∏–∑ fade –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
void analyzeFadePatterns(const std::vector<IAAFComponent*>& components, 
                        const std::vector<aafPosition_t>& positions,
                        size_t clipIndex, const aafRational_t& editRate,
                        AudioClipData& clipData) {
    
    if (clipIndex >= components.size()) return;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–µ—Ä–µ–¥ –∫–ª–∏–ø–æ–º (fade-in)
    if (clipIndex > 0) {
        IAAFComponent* pPrevComp = components[clipIndex - 1];
        IAAFFiller* pFiller = nullptr;
        IAAFTransition* pTransition = nullptr;
        
        if (SUCCEEDED(pPrevComp->QueryInterface(IID_IAAFFiller, (void**)&pFiller))) {
            // –ü—Ä–µ–¥—ã–¥—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç - Filler (fade-in)
            aafLength_t fadeLength = 0;
            pPrevComp->GetLength(&fadeLength); // –ò—Å–ø–æ–ª—å–∑—É–µ–º IAAFComponent –º–µ—Ç–æ–¥
            clipData.fadeInLength = (double)fadeLength * editRate.denominator / editRate.numerator;
            clipData.fadeInType = "Linear"; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            pFiller->Release();
            
        } else if (SUCCEEDED(pPrevComp->QueryInterface(IID_IAAFTransition, (void**)&pTransition))) {
            // –ü—Ä–µ–¥—ã–¥—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç - Transition (crossfade)
            aafLength_t transLength = 0;
            pPrevComp->GetLength(&transLength); // –ò—Å–ø–æ–ª—å–∑—É–µ–º IAAFComponent –º–µ—Ç–æ–¥
            clipData.crossfadeLength = (double)transLength * editRate.denominator / editRate.numerator;
            pTransition->Release();
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Å–ª–µ –∫–ª–∏–ø–∞ (fade-out)
    if (clipIndex + 1 < components.size()) {
        IAAFComponent* pNextComp = components[clipIndex + 1];
        IAAFFiller* pFiller = nullptr;
        IAAFTransition* pTransition = nullptr;
        
        if (SUCCEEDED(pNextComp->QueryInterface(IID_IAAFFiller, (void**)&pFiller))) {
            // –°–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç - Filler (fade-out)
            aafLength_t fadeLength = 0;
            pNextComp->GetLength(&fadeLength); // –ò—Å–ø–æ–ª—å–∑—É–µ–º IAAFComponent –º–µ—Ç–æ–¥
            clipData.fadeOutLength = (double)fadeLength * editRate.denominator / editRate.numerator;
            clipData.fadeOutType = "Linear"; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            pFiller->Release();
            
        } else if (SUCCEEDED(pNextComp->QueryInterface(IID_IAAFTransition, (void**)&pTransition))) {
            // –°–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç - Transition (crossfade)
            aafLength_t transLength = 0;
            pNextComp->GetLength(&transLength); // –ò—Å–ø–æ–ª—å–∑—É–µ–º IAAFComponent –º–µ—Ç–æ–¥
            clipData.crossfadeLength = (double)transLength * editRate.denominator / editRate.numerator;
            pTransition->Release();
        }
    }
}

// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è Audio Clip –Ω–∞ –æ—Å–Ω–æ–≤–µ Audio File –∏–º–µ–Ω–∏ –∏ Clip MobID
std::string generateAudioClipFileName(IAAFSourceClip* pClip, const std::map<std::string, std::string>& mobIdToName,
                                     IAAFHeader* pHeader, std::ofstream& out) {
    if (!pClip) return "";
    
    // –ü–æ–ª—É—á–∞–µ–º MobID —Å–∞–º–æ–≥–æ –∫–ª–∏–ø–∞ (Audio Clip)
    IAAFComponent* pComponent = nullptr;
    if (FAILED(pClip->QueryInterface(IID_IAAFComponent, (void**)&pComponent))) {
        return "";
    }
    
    // –ü–æ–ª—É—á–∞–µ–º DataDef –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —á—Ç–æ —ç—Ç–æ Audio
    IAAFDataDef* pDataDef = nullptr;
    if (SUCCEEDED(pComponent->GetDataDef(&pDataDef))) {
        // –ü—Ä–æ—Å—Ç–æ –æ—Ç–º–µ—á–∞–µ–º, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ DataDef (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∞)
        out << "    [AUDIO_CLIP] Found Audio Component" << std::endl;
        pDataDef->Release();
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ Audio File
    aafSourceRef_t ref;
    if (FAILED(pClip->GetSourceReference(&ref))) {
        pComponent->Release();
        return "";
    }
    
    std::string audioFileMobId = formatMobID(ref.sourceID);
    out << "    [AUDIO_CLIP] References Audio File MobID: " << audioFileMobId << std::endl;
    
    // –ò—â–µ–º –∏–º—è Audio File
    std::string audioFileName = "";
    std::string originalExtension = ".aif"; // –î–ª—è embedded —Ñ–∞–π–ª–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é .aif (–∫–∞–∫ –ø–æ–∫–∞–∑–∞–ª –∞–Ω–∞–ª–∏–∑)
    auto it = mobIdToName.find(audioFileMobId);
    if (it != mobIdToName.end()) {
        audioFileName = it->second;
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
        size_t dotPos = audioFileName.find_last_of('.');
        if (dotPos != std::string::npos) {
            originalExtension = audioFileName.substr(dotPos);
            audioFileName = audioFileName.substr(0, dotPos);
        }
        out << "    [AUDIO_CLIP] Audio File Name: " << audioFileName << ", Extension: " << originalExtension << std::endl;
    } else {
        // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ mobIdToName, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback naming
        out << "    [AUDIO_CLIP] Not found in mobIdToName, using fallback naming" << std::endl;
        
        // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –∏–º—è –Ω–∞ –æ—Å–Ω–æ–≤–µ MobID
        std::ostringstream nameOss;
        nameOss << "MasterMob_" << audioFileMobId;
        audioFileName = nameOss.str();
        originalExtension = ".aif"; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è embedded
        
        out << "    [AUDIO_CLIP] Generated fallback filename: " << audioFileName << originalExtension << std::endl;
    }
    
    pComponent->Release();
    
    if (audioFileName.empty()) {
        return "";
    }
    
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à –æ—Ç MobID –∫–∞–∫ –Ω–æ–º–µ—Ä –∫–ª–∏–ø–∞
    std::hash<std::string> hasher;
    size_t mobIdHash = hasher(audioFileMobId);
    int clipNumber = static_cast<int>(mobIdHash % 999) + 1; // –û—Ç 1 –¥–æ 999
    
    std::ostringstream oss;
    // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Å —Å—É—Ñ—Ñ–∏–∫—Å–æ–º –∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º
    oss << audioFileName << "_embedded_" << std::setfill('0') << std::setw(2) << clipNumber << originalExtension;
    
    std::string clipFileName = oss.str();
    
    out << "    [AUDIO_CLIP] Generated clip file name: " << clipFileName << std::endl;
    
    return clipFileName;
}

void processAudioTrackForExportWithHeader(IAAFMobSlot* pSlot, const std::map<std::string, std::string>& mobIdToName, 
                                         aafPosition_t sessionStartTC, AudioTrackData& trackData,
                                         IAAFHeader* pHeader, const std::set<std::string>& embeddedMobIDs, std::ofstream& out) {
    if (!pSlot) return;
    
    // –ü–æ–ª—É—á–∞–µ–º edit rate —Å–ª–æ—Ç–∞
    aafRational_t editRate = {25, 1}; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    IAAFTimelineMobSlot* pTimelineSlot = nullptr;
    if (SUCCEEDED(pSlot->QueryInterface(IID_IAAFTimelineMobSlot, (void**)&pTimelineSlot))) {
        pTimelineSlot->GetEditRate(&editRate);
        pTimelineSlot->Release();
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç —Å–ª–æ—Ç–∞
    IAAFSegment* pSegment = nullptr;
    if (FAILED(pSlot->GetSegment(&pSegment))) {
        return;
    }
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ–º –∫–ª–∏–ø—ã –∏–∑ —Å–µ–≥–º–µ–Ω—Ç–∞
    extractClipsFromSegment(pSegment, mobIdToName, editRate, sessionStartTC, 0, trackData, pHeader, embeddedMobIDs, out);
    
    pSegment->Release();
}
